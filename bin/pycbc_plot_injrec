#! /usr/bin/env python

import os
import sys
import sqlite3
import random

from pycbc.overlaps import overlap_utils
import numpy
from optparse import OptionParser
from pycbc import plot
from pycbc.plot import plot_utils

parser = OptionParser()
parser.add_option('-c', '--cache-file', help = 'cache file containing results databases')
parser.add_option('-o', '--plot-directory', default = '.', help = 'directory to save plot(s) to. Default is current.')
parser.add_option('-u', '--user-tag', help = 'user tag for plot(s)')
parser.add_option('-p', '--param-name', metavar='param_name[:param_label]', help = 'Name of the parameter to plot. Can optionally also specify a label to use for the parameter for the plots.')
parser.add_option('--plot-zoom', action='store_true', default=False, help='Create a second axis zoomed onto the desired area. Zoom limits are set by zoom-xlims and zoom-ylims.')
parser.add_option('--zoom-xlims', metavar='xmin,xmax', help = 'X-limits for zoomed axis. If not specified, will be the same as the full plot.')
parser.add_option('--zoom-ylims', metavar='ymin,ymax', help = 'Y-limits for zoomed axis. If not specified, will be the same as the full plot.')
parser.add_option('--param-window-db', help='Optional. Plot the parameter window in the given database. One of the parameters listed in the database must be the same as param-name.')
parser.add_option('--plot-effectualness', action='store_true', default=False, help='Optional. Color points by their effectualness.')
parser.add_option('-D', '--dpi', type = 'int', default = 300, help = 'dpi to use for plots')
parser.add_option('-S', '--point-size', type = 'int', default=3, help='point size to use for markers; default is 3.')
parser.add_option('-A', '--x-min', type = 'float', help = 'min x for plot')
parser.add_option('-B', '--x-max', type = 'float', help = 'max x for plot')
parser.add_option('-U', '--y-min', type = 'float', help = 'min y for plot')
parser.add_option('-V', '--y-max', type = 'float', help = 'max y for plot')
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help = 'apply cut to injections; can specify multiple times')

opts, _ = parser.parse_args()

if opts.zoom_xlims is not None:
    opts.zoom_xlims = map(float, opts.zoom_xlims.split(','))
if opts.zoom_ylims is not None:
    opts.zoom_ylims = map(float, opts.zoom_ylims.split(','))

if opts.param_name is None:
    raise ValueError, '--param-name is required' 
if len(opts.param_name.split(':')) == 2:
    param_name, param_label = map(str.strip, opts.param_name.split(':'))
else:
    param_name = param_label = opts.param_name.strip()

if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''
apply_cut = {}
for thiscut in opts.apply_cut:
    param, ranges = thiscut.split(':')
    apply_cut[param] = tuple(map(float, ranges.split(',')))

print "getting results"
filenames = plot_utils.parse_results_cache(opts.cache_file)
injected_vals = {}
recovered_vals = {}
sqlquery = """
SELECT
    inj.waveform, inj.mass1, inj.mass2, inj.spin1z, inj.spin2z, tmplt.mass1,
    tmplt.mass2, tmplt.spin1z, tmplt.spin2z, res.tmplt_approximant,
    res.effectualness
FROM
    sim_inspiral AS inj
JOIN
    sngl_inspiral AS tmplt, coinc_event_map AS mapA,
    coinc_event_map AS mapB
ON (
    inj.simulation_id == mapA.event_id AND
    mapA.coinc_event_id == mapB.coinc_event_id AND
    tmplt.event_id == mapB.event_id)
JOIN
    overlap_results AS res
ON
    res.coinc_event_id == mapA.coinc_event_id
"""
for ii,filename in enumerate(filenames):
    print "%i / %i\r" %(ii+1, len(filenames)),
    sys.stdout.flush()
    connection = sqlite3.connect(filename)
    try:
        connection.cursor().execute("""
        CREATE INDEX IF NOT EXISTS
            cem_ei_index
        ON coinc_event_map (event_id)""")
    except sqlite3.OperationalError:
        connection.close()
        continue
    except sqlite3.DatabaseError:
        connection.close()
        print "Database Error: %s" % filename
        continue
    try:
        for (waveform, inj_m1, inj_m2, inj_s1z, inj_s2z, found_m1,
                found_m2, found_s1z, found_s2z, tmplt_apprx, ff) in \
                connection.cursor().execute(sqlquery):
            inj = plot_utils.Result()
            inj.m1 = inj_m1
            inj.m2 = inj_m2
            inj.s1z = inj_s1z
            inj.s2z = inj_s2z
            inj.apprx = waveform
            inj.effectualness = ff
            if apply_cut and not plot_utils.result_in_range(inj, apply_cut):
                continue
            tmplt = plot_utils.Result()
            tmplt.m1 = found_m1
            tmplt.m2 = found_m2
            tmplt.s1z = found_s1z
            tmplt.s2z = found_s2z
            tmplt.apprx = tmplt_apprx
            injected_vals.setdefault((waveform, tmplt_apprx), [])
            injected_vals[waveform, tmplt_apprx].append(inj)
            recovered_vals.setdefault((waveform, tmplt_apprx), [])
            recovered_vals[waveform, tmplt_apprx].append(tmplt)
        connection.close()
    except sqlite3.OperationalError:
        connection.close()
        continue
print ""
print "getting templates"
templates = numpy.array([plot_utils.get_arg(tmplt, param_name) for tmplt in \
    plot_utils.get_templates(filenames[0])])

# get the param windows if desired
if opts.param_window_db is not None:
    connection = sqlite3.connect(opts.param_window_db)

for (inj_apprx, tmplt_apprx) in injected_vals:
    inj_params = numpy.array([plot_utils.get_arg(inj, param_name) for inj in \
        injected_vals[inj_apprx, tmplt_apprx]])
    rec_params = numpy.array([plot_utils.get_arg(tmplt, param_name) \
        for tmplt in recovered_vals[inj_apprx, tmplt_apprx]])

    if opts.plot_effectualness:
        effectualness = [inj.effectualness for inj in \
            injected_vals[inj_apprx, tmplt_apprx]]
    else:
        effectualness = []
    # load the parameter windows
    if opts.param_window_db is not None:
        print "loading parameter windows"
        pw_list = overlap_utils.ParamWindowList()
        pw_list.load_from_database(connection, param_name, inj_apprx, tmplt_apprx)

        # figure out what's missed by the parameter windows
        print "getting injections that would be missed by the parameter windows"
        missed_indices = [nn for nn,(recval, injval) in \
            enumerate(zip(rec_params, inj_params)) if recval not in \
            pw_list[pw_list.find(injval)].recovery_window(injval)]
    else:
        pw_list = missed_indices = None

    print "plotting"
    fig = plot.plot_recovered_injected(inj_params, rec_params, param_label,
        param_windows=pw_list, pwin_missed_indices=missed_indices,
        xmin=opts.x_min, xmax=opts.x_max, ymin=opts.y_min, ymax=opts.y_max,
        plot_zoom=opts.plot_zoom, zoom_xlims=opts.zoom_xlims,
        zoom_ylims=opts.zoom_ylims, point_size=opts.point_size,
        effectualness=effectualness)

    fig.savefig('%s/plot_injrec%s-%s_%s.png' %(opts.plot_directory, tag,
        inj_apprx, tmplt_apprx), dpi=opts.dpi, bbox_inches='tight')

if opts.param_window_db is not None:
    connection.close()
